<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>A Comprehensive Analysis of Gaussian Splatting Rasterization</title>
        <link rel="icon" type="image/x-icon" href="../../../assets/favicon.ico" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v6.3.0/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="../../../css/blog_style.css" rel="stylesheet" />
        <!-- Prism.js CSS -->
        <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/themes/prism.min.css" rel="stylesheet" />
        <style>
            table {
                width: 100%;
                border-collapse: collapse;
            }
            th, td {
                width: 50%;
                border: 1px solid #ddd;
                padding: 10px;
                text-align: center;
                vertical-align: middle;
            }
            th {
                background-color: #f2f2f2; 
            }
            th {
                width: 15%; /* Reduced width of the header column */
                background-color: #f2f2f2; 
            }
            .img-fluid {
                max-width: 100%;
                height: auto;
                display: block;
                margin: auto;
            }
            .wp-block-image figcaption {
                font-size: 4px;
                color: #000000;
            }
        </style>
        <!-- MathJax CSS -->
        <script src="../../../js/mathjax-config.js"></script>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({            
                tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}            
            });
        </script>
        <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
    </head>
    <body>
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-light" id="mainNav">
            <div class="container px-4 px-lg-5">
                <a class="navbar-brand" href="../../main.html">HwanHeo's Blog</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    Menu
                    <i class="fas fa-bars"></i>
                </button>
                <div class="collapse navbar-collapse" id="navbarResponsive">
                    <ul class="navbar-nav ms-auto py-4 py-lg-0">
                        <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="../../main.html">Post</a></li>
                        <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="../../../index.html">HwanHeo's log</a></li>
                    </ul>
                </div>
            </div>
        </nav>
        <!-- Page Header-->
        <header class="masthead" style="background-image: url('../../../assets/blog_bg.png')">
            <div class="container position-relative px-4 px-lg-5">
                <div class="row gx-4 gx-lg-5 justify-content-center">
                    <div class="col-md-10 col-lg-8 col-xl-7">
                        <div class="post-heading">
                            <h1>Do not Rasterize, but Ray Trace 3D Gaussian</h1>
                            <br/>
                            <span class="meta">
                                Posted by
                                Hwan Heo
                                on August 23, 2024
                            </span>
                            <div style="text-align: center;">
                                <button type="button" class="btn" onclick="setLanguage('eng')" style="font-size: 13px;">eng</button>
                                |
                                <button type="button" class="btn" onclick="setLanguage('kor')" style="font-size: 13px;">kor</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </header>
        <!-- Post Content-->
        <article class="mb-4">
            <nav class="toc">
                <ul>
                    <li>
                        <a href="#introduction"> Introduction</a>
                    </li>
                    <li><a href="#preliminary"> Background</a></li>
                    <ul>
                        <li>
                            <a href="#parameterization"> 3D Gaussian Modeling </a>
                        </li>
                        <li>
                            <a href="#hardware-accelerated-ray-tracing"> Ray Tracing </a>
                        </li>
                    </ul>
                    <li>
                        <a href="#method"> MISC</a>
                    </li>
                    <ul>
                        <li>
                            <a href="#bounding-primitives"> Bounding Primitives </a>
                        </li>
                        <li>
                            <a href="#ray-tracing-renderer"> Ray Tracing Renderer </a>
                        </li>
                        <li>
                            <a href="ray-gaussian-intersection"> Ray Gaussian Intersection </a>
                        </li>
                    </ul>
                    <li><a href="#experiments"> Experiments </a></li>
                    <li><a href="#conclusion"> Closing </a></li>
                </ul>
            </nav>
            <div class="container px-4 px-lg-5">
                <div class="row gx-4 gx-lg-5 justify-content-center">
                    <div class="col-md-10 col-lg-8 col-xl-7">
                        <h2 id="tl-dr">TL; DR</h2>
                        <p class="lang eng">This article provides an in-depth review of the paper &quot;3D Gaussian Ray Tracing,&quot; which introduces a novel approach to leveraging ray tracing in 3D Gaussian Radiance Fields.</p>
                        <p class="lang eng">3D Gaussian Splatting is a powerful and fascinating technology, but there are several problems inherited from rasterization. The recently presented 3D Gaussian Ray Tracing (3D GRT, hereinafter) resolves many of these shortcomings by introducing a Differentiable Ray Tracer for 3D Gaussian. Let’s deep dive into the 3D GRT!</p>
                        <p class="lang kor" style="display: none;">3D Gaussian Splatting 은 강력하고 매력적인 기술이지만, rasterization 을 사용하기 때문에 생기는 여러 문제가 있다. 최근 공개된 3D Gaussian Ray Tracing (이하 3D GRT) 은 Ray Tracing 기술을 3D Gaussian 에 접목시켜 이러한 단점을 많이 해결한 모습을 보여주었다. 이 글을 통해 3D GRT 를 자세하게 알아보자! </p>
                        <figure>
                            <img src="assets/teaser.gif" alt="Gaussian RT" width="100%">
                            <figcaption style="text-align: center; font-size: 15px;"><strong></strong> 3D Gaussian Ray Tracing</figcaption>
                        </figure>
                        <br/>
                        
                        <h2 id="introduction"> 1. Introduction</h2><br/>
                        <h3 id="challenges-in-3d-gaussian-splatting">Challenges in 3D Gaussian Splatting</h3>
                        <p class="lang eng">3D Gaussian Splatting (3D GS) has emerged as a promising approach for high-fidelity novel-view synthesis and real-time rendering, leveraging a sophisticated tile-based rasterization technique. Despite its potential, this area, often referred to as the next frontier in photogrammetry, continues to face several significant challenges.</p>
                        <p class="lang eng">A major limitation of 3D GS arises from its reliance on rasterization, which introduces several constraints:</p>
                        <ol>
                            <li>
                                <p><strong>Inflexibility with Diverse Camera Models</strong><br/>
                                    One of the primary limitations of 3D Gaussian Splatting is its inflexibility in accommodating various camera models.
                                    As highlighted in recent analyses of 3D GS rasterization, the use of EWA splatting introduces affine projection errors. 
                                    These errors complicate to achieve high-quality results, even when modeling non-pinhole camera types.
                                </p>
                            </li>
                            <li><p><strong>Sensitivity to Image Quality</strong><br/> Unlike NeRF, which utilize MLPs and exhibit a degree of robustness against calibration discrepancies between images, 3D GS relies on explicit geometric primitives. This reliance renders 3D GS highly sensitive to variations in image quality, including issues such as motion blur and rolling shutter effects, which can significantly degrade the final output.</p>
                            </li>
                            <li><p><strong>Lack of Physically-Based Rendering Capabilities</strong><br/>
                                Another challenge facing 3D GS is its inability to incorporate physically-based rendering (PBR) effects. Since 3D GS does not adhere to the principles of PBR, accurately modeling lighting and reflection effects within a scene remains problematic. This limitation restricts the realism and applicability of 3D GS in scenarios where accurate light interaction is critical.</p>
                            </li>
                        </ol>
                        <p class="lang eng">To address some of these challenges, RadSplat proposes a two-stage learning process. In this approach, Radiance Fields are first learned using Zip-NeRF, which generates perfectly calibrated pinhole images within the NeRF scene. These images are then used as training data for 3D GS.</p>
                        <p class="lang eng">However, this method is inefficient due to its two-stage nature and fails to resolve the fundamental limitations posed by rasterization, particularly in relation to physically-based rendering.</p>
                        
                        <p class="lang kor" style="display: none;">3D Gaussian Splatting 은 well-designed tile-based rasterizer 를 이용해 high-fidelity novel-view synthesis 와 real-time rendering 을 달성한 연구이다. </p>
                        <p class="lang kor" style="display: none;">Next-photogramerry 로까지 불리며 각광받고 있는 연구분야지만, 아직 과도기이기 때문에 극복해야할 문제가 많이 남아있다. </p>
                        <p class="lang kor" style="display: none;">그 중 대표적인 것이 바로 Rasterization 사용으로 인한 한계점들이다.   </p>
                        <ol class="lang kor" style="display: none;">
                            <li><strong>Inflexibility to Various Camera Models</strong> 
                            3D GS rasterization 분석글 에서도 지적한 바와 같이 EWQ splatting 으로 구현된 rasterization 은 affine projection error 가 있으며, 이 때문에 다양한 camera 에 대한 modeling 을 구현하더라도 high-quality 로 학습하는 것이 쉽지 않다. </li>
                            <li><strong>Sensitive to Image Quality</strong> 
                            MLP 로 이루어진 NeRF 는 image 간 calibration 차이에도 일부 강건하지만, 3D GS 는 explicit primitive 를 사용하기 때문에 motion blur, rolling shutter 등 image quality 에 극도로 민감하다.  </li>
                            <li><strong>Incapability of Physicall-based Effect</strong>
                            Physically-based Rendering 이 아니기 때문에 조명, 반사 효과 등을 모델링하기 힘들다.</li>
                        </ol>
                        <p class="lang kor" style="display: none;">1), 2) 등에 대해서는 RadSplat 에서 Zip-NeRF 로 Radiance Fields 를 먼저 학습한 후, NeRF scene 에서 perfect &amp; calibrated pinhole image 를 rendering 하여 3D GS 의 training data 로 사용하면서 우회한 바 있다. </p>
                        <p class="lang kor" style="display: none;">하지만 이 학습 방법은 2-stage 기 때문에 효율적이지 못하며, 근본적으로 rasterization 이기 때문에 갖는 3) 은 여전히 challenge 로 남아있다. </p>
                        
                        <h2 id="preliminary"> 2. Background </h2>
                        <br/>
                        <h3 id="parameterization">2.1. Parameterization</h3>
                        <p class="lang eng">The primitive kernel in this method is defined using the covariance matrix in 3D space, consistent with the original 3D GS approach. Due to this shared kernel definition, most calculations remain similar between the two methods. However, there is a notable difference concerning the direction used when calculating Spherical Harmonics to RGB (SH2RGB).</p>
                        <p class="lang eng">In 3D GS, the direction is derived from the camera position $o$ and the Gaussian means $\mu$, which is then utilized in SH2RGB calculations. This approach, however, results in a direction that slightly deviates from the actual angle projected onto the pixel. </p>
                        
                        <p class="lang kor" style="display: none;">Primitive kernel 은 original 3D GS 와 같이 3D 공간에서 covariance matrix 를 통해 정의된다. </p>
                        <p class="lang kor" style="display: none;">Kernel 정의가 같기에 다른 계산들도 3D GS 와 유사하지만, Spherical Harmonics to RGB 계산에 사용되는 direction 에 대해 짚고 넘어갈 차이점이 있다. </p>
                        <p class="lang kor" style="display: none;">3D GS 에서는 camera position $o$, Gaussian means $\mu$ 를 입력으로 받아 direction 을 만들어 이를 SH2RGB 에 이용한다. 즉 실제 pixel 에 투영되는 각도와는 약간 다른 값을 사용하는 것인데, ray direction 을 사용하지 않은 이유는 tile-wise 로 rasterization 을 진행할 때 color 값 등을 미리 저장해두고 사용하기 때문이다.  (Refer to) </p>
                        <div class="math-container">
                            $$G(x) = \exp \left( {- \frac{1}{2} x^{\rm T} \Sigma^{-1} x} \right )$$
                        </div>

                        <pre><code class="language-cpp" style="font-size: 16px;">// in preprocessCUDA
glm::vec3 result = computeColorFromSH(idx, D, M, (glm::vec3*)orig_points, *cam_pos, shs, clamped);
rgb[idx * C + 0] = result.x;
rgb[idx * C + 1] = result.y;
rgb[idx * C + 2] = result.z;</code></pre>
                        <ul class="lang eng">
                            <li>The precomputed RGB is then input to the Render kernel.</li>
                        </ul>
                        <ul class="lang kor" style="display: none;">
                            <li>이렇게 미리 계산해둔 rgb 를 Render kernel 에 입력으로 넣어 pre-computed color 를 사용한다.</li>
                        </ul>

                        <p class="lang eng">The reason for not using the precise ray direction is that color values are pre-computed and stored for use during tile-wise rasterization. This pre-computed RGB data is subsequently fed into the render kernel, optimizing rendering speed.</p>
                        <p class="lang eng">While this method enhances rendering performance, it compromises the ability to accurately model illumination effects—one of the inherent weaknesses of 3D GS. To address this issue, the 3D GRT utilizes the actual ray direction in SH2RGB calculations, improving illumination effect modeling.</p>
                        <p class="lang kor" style="display: none;">이 방법을 사용하면 rendering 속도는 극대화되지만, 3D GS 의 약점 중 하나인 illumination effect modeling 에 더 약점을 보이는 설계가 된다. 3D GRT 에서는 이를 방지하기 위해 SH2RGB 에서 ray direction 을 사용한다고 한다. </p>
                        
                        <h3 id="hardware-accelerated-ray-tracing"> 2.2. Hardware-Accelerated Ray Tracing</h3>
                        <div class="lang eng">
                            <p>NVIDIA GPUs, particularly those in the RTX series, are equipped with dedicated RT cores designed for ray tracing. These RT cores handle the intersection calculations between rays and particles, while the more computationally demanding tasks, such as shading, are assigned to the Streaming Multiprocessors (SMs), optimizing overall performance.</p>
                            <p>However, existing ray tracers are typically optimized for rendering opaque particles. This means that during ray traversal, the expected hit count is low, and interaction between the SMs and RT cores is minimized. </p>
                            <p>Since 3D Gaussian Splatting involves semi-transparent particles, conventional ray tracers are inefficient in this context. The semi-transparency of 3D Gaussian Splatting increases the complexity of ray tracing, requiring more sophisticated handling of ray-particle intersections to achieve efficient and accurate rendering.</p>
                        </div>
                        <p class="lang kor" style="display: none;">NVIDIA 계열 GPU 는 ray tracing 을 위한 RT cores 가 따로 설계되어 있어, ray 와 particle 의 intersection 은 RT core 가 담당하고, shading 에 해당하는 더 계산량이 높은 작업은 SMs 에게 할당하는 식으로 최적화 되어 있다.</p>
                        <p class="lang kor" style="display: none;">기존에 설계된 Ray Tracer 들은 opaque particle 을 렌더링하는데 초점이 맞추어 설계되어 있다. 즉, ray traversal 과정에서 예상되는 hit count 가 낮으며, SMs RT 코어 간의 상호 작용이 최소화된다.</p>
                        <p class="lang kor" style="display: none;">하지만 3D Gaussian 은 semitransparent 하기 때문에 conventional Ray Tracer 가 효율적이지 못하며, 따라서 3D Gaussian 을 위한 적절한 Ray Tracing 알고리즘을 설계해야할 것이다. </p>
                        
                        <h2 id="method"> 3. 3D Gaussian Ray Tracing </h2>
                        <figure>
                            <img class="img-fluid" src="assets/fig1.png" width="100%">
                            <figcaption style="text-align: center; font-size: 15px;"><strong>Figure 1.</strong> Method Overview</figcaption>
                        </figure>
                        <p class="lang eng">To effectively design a ray tracer tailored for 3D Gaussian Splatting, two key elements are essential:</p>
                        <ol class="lang eng">
                            <li><p><strong>BVH with Appropriate Proxy Primitives</strong><br/>Use Bounding Volume Hierarchy (BVH) to accelerate hit traversal by defining proxy primitives that encapsulate 3D Gaussians accurately.</p>
                            <figure>
                                <img class="img-fluid" src="assets/fig2.png" width="50%">
                                <figcaption style="text-align: center; font-size: 15px;"><strong>Figure 2.</strong> bounding primitive </figcaption>
                            </figure>
                            </li>
                            <li><p><strong>Rendering Algorithm</strong><br/> Develop a rendering algorithm that casts rays and gathers information specific to 3D Gaussian Ray Tracing, optimizing the process for the unique characteristics of Gaussian splats.</p>
                            </li>
                        </ol>
                        <p class="lang kor" style="display: none;">3D Gaussian 을 위한 Ray Tracer 설계를 위해 다음 두가지의 핵심 요소가 필요하다. </p>
                        <ul class="lang kor" style="display: none;">
                            <li>Hit traversal 가속화를 위해 BVH 를 사용하는데, BVH 를 위한 proxy primitive 를 3D Gaussian 에 알맞게 정의할 것
                                <figure>
                                    <img class="img-fluid" src="assets/fig2.png" width="50%">
                                    <figcaption style="text-align: center; font-size: 15px;"><strong>Figure 2.</strong> bounding primitive </figcaption>
                                </figure>
                            </li>
                            <li>3D Gaussian Ray Tracing 의 rendering algorithm (cast ray &amp; gather information) 을 알맞게 정의할 것</li>
                        </ul>
                        <p class="lang kor" style="display: none;">
                            각 요소에 유의하며 3D GRT 설계를 따라가보자.
                        </p>
                        <br/>

                        <h3 id="bounding-primitives"> 3.1. Bounding Primitives</h3>
                        <p class="lang eng">Let&#39;s start with BVH (Bounding Volume Hierarchy).</p>
                        <p class="lang kor" style="display: none;">간단하게 BVH (Bounding Volume Hierarchy) 부터 짚고 넘어가자. </p>
                        <figure>
                            <img class="img-fluid" src="assets/fig3.png" width="90%">
                            <figcaption style="text-align: center; font-size: 15px;"><strong>Figure 3.</strong> Bounding Volume Hierarchy</figcaption>
                        </figure>
                        <p class="lang eng">BVH is a hierarchical tree structure used to efficiently divide space for rendering and ray tracing. In this structure, parent nodes consist of larger bounding volumes that encompass smaller leaf nodes, facilitating efficient space partitioning and exploration. The main objective of BVH in this context is to define a proxy primitive that accurately encapsulates 3D Gaussians and to use this proxy geometry to construct a BVH. This hierarchy then guides the ray traversal process by determining which 3D Gaussians should be considered for intersection tests.</p>
                        <p class="lang eng">NVIDIA OptiX, a common framework for ray tracing, offers three predefined proxy primitive types: triangles, spheres, and axis-aligned bounding boxes (AABBs). However, none of these are ideal for 3D Gaussians. For instance, using AABBs would simplify calculations but would lead to many false-positive proxy hits, as AABBs cannot tightly enclose the Gaussian distribution, leading to inefficiencies in ray tracing.</p>
                        
                        <p class="lang kor" style="display: none;">BVH 란, 공간을 분할하여 hierarchy 로 나타낸 tree structure 이다. Parants node 는 더 큰 bounding volumes 으로 leefs 를 완전히 감싸는 형태로 이루어져있으며, 이를 통해 효율적으로 공간을 분할 탐색할 수 있게 된다. </p>
                        <p class="lang kor" style="display: none;">즉 BVH 의 목적은 3D Gaussian 을 적절하게 감싸는 proxy primitive 를 정의하고, 이 proxy geometry 로 BVH 를 구성하여 어떠한 3D Gaussian 들을 ray traversal 과정에서 탐색할 것인지를 결정하는 것이다. </p>
                        <p class="lang kor" style="display: none;">NVIDIA OptiX 에서는 미리 정의된 3가지 타입 1) triangle, 2) sphere and 3) AABBs 가 있지만, 3가지 모두 3D Gaussian 에 적절하지 않다고 한다. 3) 의 AABB 를 이용하는 경우를 생각해보면, 계산은 간단하지만 false positive proxy hit 이 많아지기 때문에 trade-off 가 있다 (Fig4 first).</p>

                        <h4 id="stretched-polyhedron-proxy"> Stretched Polyhedron Proxy</h4>
                        <figure>
                            <img class="img-fluid" src="assets/fig4.png" width="90%">
                            <figcaption style="text-align: center; font-size: 15px;"><strong>Figure 4.</strong> Proxy Primitives</figcaption>
                        </figure>
                        <p class="lang eng">After experimental evaluations, the authors found that using an icosahedron—a polyhedron with 20 triangular faces—was the most appropriate proxy geometry for 3D Gaussians.</p>
                        <p class="lang eng">The benefits of using an icosahedron include:</p>
                        <ul class="lang eng">
                            <li><strong>Efficient Ray-Face Intersection Calculation</strong>: Since the icosahedron consists of triangular faces, the intersection tests between rays and these faces are optimized at the hardware level.</li>
                            <br/>
                            <li><strong>Accurate Wrapping</strong>: The icosahedron can wrap around a 3D Gaussian distribution effectively, minimizing both false positives and false negatives.</li>
                        </ul>
                        <p class="lang eng">For an icosahedron inscribed in a unit sphere, the proxy geometry is computed by transforming each vertex using the following formula:</p>
                        
                        <p class="lang kor" style="display: none;">저자들은 실험을 통해 Icosahedron (정이십면체) 를 사용하는 것이 가장 적절했다고 한다. </p>
                        <ul class="lang kor" style="display: none;">
                            <li>Icosahedron 은 triangular face 로 이루어져 있기 때문에 ray-face intersection 을 계산하는 것이 hardware optimized 되어 있다.</li>
                            <li>3D Gaussian 에 대해 false positive, false negative 가 너무 많지 않게 감쌀 수 있는 적절한 모양이다.</li>
                        </ul>
                        <p class="lang kor" style="display: none;">Unit sphere 를 내접하는 icosahedron 에 대하여, 3D Gaussian 에 대한 minimum responce alpha (0.01 로 설정) 값을 통해 각 vertex 를 다음과 같이 transform 하여 proxy geometry 를 계산한다. </p>

                        <p>$$
                        v \leftarrow v \sqrt{2 \log (\sigma / \alpha_{\min})} \ {\rm SR^T} + \mu 
                        $$</p>
                        <p class="lang eng">To break down this formula:</p>
                        <ol class="lang eng">
                            <li><p><strong>Stretching</strong></p>
                                <p>The transformation matrix ${SR^{\rm T}}$ and mean vector $\mu$ adjust the icosahedron to fit the local coordinates of the 3D Gaussian. This involves stretching, rotating, and translating the initial icosahedron to properly enclose the 3D Gaussian distribution.</p>
                            </li>
                            <li><p><strong>Adaptive Clamping</strong></p> 
                                <p>The scaling term $\sqrt{2 \log (\sigma / \alpha_{\min})}$ determines how the icosahedron is scaled. Specifically, the parameter $\alpha_{\min}$ (set to 0.01) represents the minimum response value, and $\sigma$ is the standard deviation of the Gaussian. When there is no change in scale, this relationship simplifies to:</p>
                            <p> $$
                            \sigma / \alpha_{\min} = \exp(0.5) \ \rightarrow \sigma \cdot \exp (- 1/2) = \alpha_{\min}<br> $$
                            </p>
                            <p> Doesn&#39;t the left side look familiar? This expression closely resembles the probability density function (pdf) of a Gaussian distribution. </p>
                            <p> In essence, the scaling factor adjusts the icosahedron to match the point where the response in the Gaussian distribution drops to $\alpha_{\min}$, effectively clamping the scale at a confidence interval where the standard deviation equals 1.</p>
                            <p> The choice of $\alpha_{\min} = 0.01$ is justified by calculating the Gaussian pdf at a standard deviation of 2.6, which corresponds to approximately 99% confidence, yielding a value close to 0.01. </p>
                            <p> $$
                            \exp\left(-\frac{1}{2}(2.6)^2 \right) \cdot \frac{1}{\sqrt{2 \pi}} \approx 0.01
                            $$
                            </p>
                            <p> Similarly, 3D GS uses a scaling factor equivalent to three times the standard deviation to compute the radius for culling.</p>
                            <p> Adaptive Clamping allows for the scaling of the proxy primitive to be small for nearly transparent particles and larger for more opaque ones, improving the accuracy and efficiency of the ray tracing process.</p>
                            </li>
                        </ol>
                        <p class="lang kor" style="display: none;">논문에 공식만 턱 나와 있어서 당황스러울 수 있는데, 차근차근 분석해보자. </p>
                        <ol class="lang kor" style="display: none;">
                            <li><p><strong>Stretching</strong><br/>
                            먼저 ${SR^{\rm T}}$ 과 $\mu$ 은 3D Gaussian 이 정의된 local coordinate 로의 transform 이다. 즉 init Icosahedron 을 3D Gaussian 에 맞게 이동하고, 적절히 늘리고 회전하는 작업이다. </p>
                            </li>
                            <li><p><strong>Adaptive Clamping:</strong><br/>
                            scaling 공식을 살펴보면, scale 이 변하지 않을 때가 다음과 같음을 알 수 있다. </p>
                            <p> $$
                            \sigma / \alpha_{\min} = \exp(0.5) \ \rightarrow \sigma \cdot \exp (- 1/2) = \alpha_{\min}<br> $$</p>
                            <p> left side 가 익숙하지 않은가? gaussian distribution 의 pdf 형태와 닮아 있다. 즉 scale 이 1로 유지되는 기점은 3D Gaussian 의 local coordinate 에서 std 가 1만큼 떨어져 있는 곳의 responce 가 minimum responce 값보다 작은지 큰지를 결정하는 지점이 된다. </p>
                            <p> 0.01 에 대한 당위성이 없다고 생각할 수도 있는데, confidence 99% 정도에 해당하는 std 값 2.6을 통해 gaussian pdf 를 계산해보면 대략 0.01 이란 값이 나온다. 비슷하게 3D GS 에서는 culling 을 위한 radius 계산에 3xstd 값을 이용한다.</p>
                            <p> $$
                            \exp\left(-\frac{1}{2}(2.6)^2 \right) \cdot \frac{1}{\sqrt{2 \pi}} \approx 0.01
                            $$</p>
                        </li>
                        </ol>

                        <p class="lang eng">This approach enables a more efficient and accurate ray tracing mechanism for 3D Gaussians by using an optimized proxy geometry that is both computationally feasible and tightly conforms to the Gaussian distribution.</p>
                        <p class="lang kor" style="display: none;">Adaptive Clamping 는 opacity 까지 scaling 에 함께 활용하기 때문에, 거의 투명하지만 크기는 큰 particle 에 대해서는 실제 proxy primitive 가 작게 설정되는 등의 이점이 존재한다. </p>

                        <h3 id="ray-tracing-renderer"> 3.2. Ray Tracing Renderer</h3>
                        <figure>
                            <img class="img-fluid" src="assets/fig5.png" width="100%">
                            <figcaption style="text-align: center; font-size: 15px;"><strong>Figure 5.</strong> Ray Tracing </figcaption>
                        </figure>
                        <p class="lang eng">For differentiable and efficient rendering in 3D GRT, the process involves sequentially rendering through a sorted k-buffer. The k-buffer approach helps in managing multiple semi-transparent particles along a single ray path. The rendering process is outlined as follows:</p>
                        <ol class="lang eng">
                            <li><p><strong>Track Particles Using BVH</strong><br/>The next k particles along a ray path are tracked using the BVH. At this stage, the hit response (i.e., the particle&#39;s contribution to the final image) is not yet measured.</p>
                            </li>
                            <li><p><strong>Measure Hit Response Iteratively</strong><br/> Once the k particles are identified, the actual hit response for each particle is measured iteratively within each chunk of the k-buffer. This step involves checking all particles that intersect with the ray.</p>
                            </li>
                            <li><p><strong>Proxy Hit Verification</strong><br/> During the response measurement, all proxy-hit particles along the ray are checked to determine their actual contribution based on their proximity and alignment with the ray.</p>
                            </li>
                            <li><p><strong>Rendering Termination</strong><br/> The rendering process continues until a certain threshold is reached, beyond which additional particle contributions are negligible, and rendering can be stopped.</p>
                            </li>
                        </ol>
                        <p class="lang eng">The following diagram (referenced in the text) illustrates the ray tracing process of 3D GRT when k=3, showing how multiple particles are managed and rendered along a single ray.</p>
                        
                        <p class="lang kor" style="display: none;">미분 가능하고 효율적인 렌더링을 위해 3D GRT 는 sorted k-buffer 를 통해 순차적으로 rendering 을 진행한다. </p>
                        <ul class="lang kor" style="display: none;">
                            <li>BVH 를 이용해 next k particle 을 추적하고 (이때는 hit response 를 측정하지 않는다)</li>
                            <li>각 chunk 내에서 실제 hit response 를 iterative 하게 측정한다
                                <ul>
                                    <li>이때, ray 내의 모든 proxy hit particle 을 검사하거나</li>
                                    <li>일정 threshold 에 도달하면 rendering 을 종료한다.</li>
                                </ul>
                            </li>
                        </ul>
                        <p class="lang kor" style="display: none;">다음 그림은 k=3 일 때 3D GRT 의 ray tracing 과정을 도식화한 것이다. </p>
                        <figure>
                            <img class="img-fluid" src="assets/fig6.png" width="80%">
                            <figcaption style="text-align: center; font-size: 15px;"><strong>Figure 6.</strong> Ray-Traversal w/ k-buffer </figcaption>
                        </figure>
                        <br/>

                        <h3 id="ray-gaussian-intersection"> 3.3. Ray-Gaussian Intersection</h3>
                        <p class="lang eng">To calculate the contribution of each particle during ray tracing, 3D GRT determines the point where the particle&#39;s response (or contribution to the final rendered image) is maximized. This is achieved through the following mathematical formulation:</p>
                        <p class="lang kor" style="display: none;">우리는 이제 어떻게 각 particle 의 contribution 을 계산할 것인가를 결정해야 한다. 3D GRT 에서는 이를 입자가 최대 response 가지는 지점을 다음과 같이 계산한다고 제시하는데</p>

                        <p>$$
                        \tau_{\max} = \frac{(\mu - \mathbf{o})^{\rm T} \Sigma^{-1} \mathbf{d}}{\mathbf{d}^{\rm T} \Sigma^{-1} \mathbf{d} } = \frac{-\mathbf{o}_g^{\rm T} \mathbf{d}_g}{\mathbf{d}_g^{\rm T}\mathbf{d}_g}
                        $$</p>
                        <p>where </p>
                        <p>$$
                        o_g = S^{-1}R^T(o-\mu ), d_g = S^{-1}R^Td.
                        $$</p>
                        
                        <div class="lang eng">
                            <p>Let&#39;s interpret this step by step without panicking.</p>
                            <p><strong>Step-by-Step Interpretation:</strong></p>
                            <ol>
                                <li><p><strong>Transformation to Local Coordinates</strong></p>
                                <p> The variables $\mathbf{o}_g$ and $\mathbf{d}_g$ represent the ray origin and direction, respectively, transformed into the local coordinate system of the 3D Gaussian, just as the proxy primitive is defined in these local coordinates.</p>
                                </li>
                                <li><p><strong>Maximizing Gaussian Density</strong></p>
                                <p> The density of the 3D Gaussian can be expressed as a 1D Gaussian along the ray path:</p>
                                <p> $$
                                G(x_g) = \exp\left(-\frac{1}{2} x_g^{\rm T} x_g\right) \quad \text{where } x_g = \mathbf{o}_g + t\mathbf{d}_g
                                $$</p>
                                <p> The goal is to find the point along the ray where this density is maximized. Since $\exp(-x)$ is a decreasing function, the maximum density corresponds to the minimum value of the inner quadratic term.</p>
                                </li>
                                <li><p><strong>Optimization</strong> </p>
                                <p> The problem of finding the maximum density is equivalent to solving the following optimization problem:</p>
                                <p> $$
                                \min_x \left(-\frac{1}{2} x_g^{\rm T} x_g\right) \\ \rightarrow \quad \max_t \left(t^2 \mathbf{d}_g^{\rm T} \mathbf{d}_g + 2 \mathbf{d}_g \cdot \mathbf{o}_g + \mathbf{o}_g^{\rm T} \mathbf{o}_g\right)
                                $$</p>
                                <p> Since this is a convex function with respect to $t$, the maximum can be found by setting the derivative with respect to $t$ to zero:</p>
                                <p> $$
                                \nabla_t f(t) = 2t \mathbf{d}_g^{\rm T}\mathbf{d}_g + 2 \mathbf{d}_g \cdot \mathbf{o}_g = 0 \\ \rightarrow \quad t = -\frac{\mathbf{o}_g^{\rm T} \mathbf{d}_g}{\mathbf{d}_g^{\rm T}\mathbf{d}_g}
                                $$</p>
                                <p> This equation represents the point along the ray where the Gaussian density, and therefore the particle&#39;s contribution to the final image, is maximized.</p>
                                </li>
                            </ol>
                            <p>Intuitively, The closer the ray direction $\mathbf{d}_g$ is to the origin of the 3D Gaussian, the higher the response or contribution from that particle will be. </p>
                            <p>Note that, even though ray tracing is performed in the order of proxy hits, the approximation using this method does not significantly degrade performance, despite any slight differences between proxy hit order and actual maximum response order. </p>
                        </div>

                        <p class="lang kor" style="display: none;">이 또한 당황하지 말고 차근차근 해석해보자. </p>
                        <p class="lang kor" style="display: none;"> $o_g$ 와 $d_g$ 에 정의를 살펴보면 proxy primitive 정의와 마찬가지로 3D Gaussian 의 local coordinate 로의 transform 된 origin, direction (non-unit vector) 임을 알 수 있다. </p>
                        <p class="lang kor" style="display: none;">즉 우리는 3D Gaussian density 를 다음과 같은 1D Gaussian density 로 쓸 수 있는데, </p>
                        <p class="lang kor" style="display: none;">$$
                        G(x_g ) =\exp(- \frac{1}{2} x_g^T x_g) \ \text{where } x_g = o_g + t d_g 
                        $$</p>
                        <p class="lang kor" style="display: none;"> $e^{-x}$ 는 decreasing function 이므로 inner quadratic term 값이 최소일 때 gaussian density 값이 최대임을 알 수 있다. </p>
                        <p class="lang kor" style="display: none;">즉, 어떤 gaussian 에 대한 maximum density 를 찾는 문제는 다음과 같은 최적화 문제로 쓸 수 있으며, </p>
                        <p class="lang kor" style="display: none;">$$
                        \max_x - \frac{1}{2} x_g^T x_g \\ \rightarrow \max_t \ t^2 d_g^T d_g + 2 d_g \cdot o_g + o_g ^T o_g 
                        $$</p>
                        <p class="lang kor" style="display: none;">이는 $t$ 에 대한 convex function 이기 때문에 derivative 가 0인 극소점에서 minimum 을 구할 수 있다.</p>
                        <p class="lang kor" style="display: none;">$$
                        \nabla_t f(t) = 2t d_g^Td_g + 2 d_g \cdot o_g = 0 , \\ \rightarrow t = - \frac{\mathbf{o}_g^{\rm T} \mathbf{d}_g}{\mathbf{d}_g^{\rm T}\mathbf{d}_g}
                        $$</p>
                        <p class="lang kor" style="display: none;">직관적으로 생각해도 자명한데, $o, d$ 가 3D Gaussian 이 정의하는 elliptical space 로 transform 되어 있으므로, ray direction 이 3D Gaussian origin 과 align 되어 있을 수록, 거리가 가까울 수록 높은 reponce 를 보이게 된다. </p>
                        <p class="lang kor" style="display: none;">Ray tracing 은 proxy hit 순서로 진행되기 때문에 실제로 ray 에 대한 particle 들의 maximum responce 의 순서와는 약간 다를 수 있지만, 이 approximation 이 성능 저하를 초래하지 않았다고 한다. </p>
                        
                        
                        <h2 id="experiments"> 4. Experiments</h2><br/>
                        <h3 id="quantitative-results"> 4.1. Quantitative Results</h3>
                        <p class="lang eng">The quantitative evaluations of 3D GRT indicate that there is almost no significant difference between the quantitative metrics of 3D GS and other novel view synthesis (NVS) techniques. While the frames per second (fps) are slightly lower in comparison, 3D GS still achieves real-time performance.</p>
                        <p class="lang kor" style="display: none;">정량적 평가 모두 훌륭하게 제시되어 있다. (역시 갓비디아…) </p>
                        <p class="lang kor" style="display: none;">3D GS 와 NVS quantitative results 는 거의 차이나지 않으며, fps 는 조금 느리지만 여전히 real-time 을 달성한다. </p>
                        <figure>
                            <img class="img-fluid" src="assets/fig7.png" width="100%">
                            <figcaption style="text-align: center; font-size: 15px;"><strong>Figure 7.</strong> Quantitative Results </figcaption>
                        </figure>
                        <figure>
                            <img class="img-fluid" src="assets/fig8.png" width="70%">
                            <figcaption style="text-align: center; font-size: 15px;"><strong>Figure 8.</strong> Speed Comparison </figcaption>
                        </figure>
                        <br/>

                        <h3 id="ablation-study-and-ray-tracer-design"> 4.2. Ablation Study</h3>
                        <p class="lang eng">The paper also includes an ablation study focused on the design of the Ray Tracer. This study explores various aspects such as the justification for the proxy mesh design and the determination of an optimal k value in the k-buffer, which is crucial for managing multiple semi-transparent particles during rendering.</p>
                        <p class="lang eng">The study provides experimental evidence that supports the choices made in the design of the Ray Tracer, highlighting the importance of these parameters in achieving efficient and accurate rendering. By systematically analyzing the impact of these design decisions, the study offers valuable insights into how different elements contribute to the overall performance and quality of the rendering process.</p>
                        <p class="lang kor" style="display: none;">Ray Tracer 설계에 대한 ablation study 도 제공하는데, proxy mesh design 에 대한 당위성이나 k buffer 에서 적절한 k 값을 설정하는 등의 실험이 보고되어있다.  </p>
                        <figure>
                            <img class="img-fluid" src="assets/fig9.png" width="100%">
                            <figcaption style="text-align: center; font-size: 15px;"><strong>Figure 9.</strong> Ablation Study </figcaption>
                        </figure>
                        <br/>

                        <h3 id="qualitative-results"> 4.3. Qualitative Results</h3>
                        <p class="lang eng">In addition to the quantitative analysis, the qualitative results demonstrate how this method effectively overcomes the limitations of rasterization that were previously identified. Specifically, the system shows significant improvements in modeling and rendering, particularly in handling complex light effects across various camera models. This ability to accurately represent lighting and reflections, which are often challenging in rasterization-based techniques, suggests that the method could be highly effective in realistic rendering scenarios.</p>
                        <p class="lang eng">Overall, the combination of both quantitative and qualitative evaluations highlights the strengths of this new 3D GS approach, especially in terms of performance, memory efficiency, and the ability to handle complex visual effects.</p>
                        
                        <p class="lang kor" style="display: none;">Qualitative Results 에서는 앞서 지적한 rasterization 의 한계점을 타파한 모습들을 보여준다. 다양한 camera model 에 대한 rendering 및 light effect 를 모델링하는 모습을 통해 3D GRT 가 효과적으로 구현되었음을 입증한다. </p>
                        <figure>
                            <img class="img-fluid" src="assets/fig10.png" width="100%">
                            <figcaption style="text-align: center; font-size: 15px;"><strong>Figure 10.</strong> 3D GRT w/ various light effect </figcaption>
                        </figure>
                        <figure>
                            <img class="img-fluid" src="assets/fig11.png" width="100%">
                            <figcaption style="text-align: center; font-size: 15px;"><strong>Figure 11.</strong> 3D GRT's reconstruction capability for non-pinhole camera </figcaption>
                        </figure>
                        <br/>
                        
                        <h2 id="conclusion"> 5. Conclusion</h2>
                        <div class="lang eng">
                            <p>This paper presents a comprehensive exploration of the differences and advantages of using a ray tracing-based renderer for 3D Gaussian Splatting compared to traditional rasterization techniques. </p>
                            <p>While rasterization excels in speed, especially for primary rays from pinhole cameras, 3D GRT offers greater flexibility and generality. It enables advanced rendering effects such as reflections, refractions, depth of field, and complex camera models, which are difficult or impossible to achieve with rasterization.</p>
                            <p>The ray tracing approach significantly broadens the scope of 3D GS, allowing for more accurate modeling of general lighting, image formation, and sub-pixel behaviors. It also facilitates the exploration of global illumination, inverse lighting, and physically-based surface reflection models, paving the way for new research directions in these areas.</p>
                            <p>However, the inherent trade-offs between the two methods are evident. While rasterization remains faster in scenarios involving primary rays and static scenes, our ray tracer, despite being carefully optimized for hardware acceleration, still requires more computational resources, particularly when frequent BVH rebuilds are necessary for dynamic scenes.</p>
                        </div>
                        
                        <div class="lang kor" style="display: none;">
                            <p>역시 갓비디아… 역작 논문인 것 같다. </p>
                            <p>Rasterization 으로 인한 한계는 3D GS 의 단점으로 지속적으로 제기되는 중이고, camera modeling 에 대한 문제나 illumination modeling 등은 각기 다른 하위 주제로써 활발히 후속 연구들이 제시되고 있다. </p>
                            <ol>
                            <li>3D GS DR </li>
                            <li>On the error analysis of 3D Gaussian</li>
                            </ol>
                            <p>그런데 rasterization 을 사용하는 것에 제한되어 이를 해결하는 대신 ray tracing 을 어떻게 3D Gaussian 에 효율적으로 구현할 수 있을지 치열하게 연구하고 실험한 흔적이 엿보이는 훌륭한 논문이었다. </p>
                            <p>물론 논문에 언급된 바와 같이 최대한 효율적인 설계를 지향했음에도 rasterization 보다는 느린 속도를 보여준다. 하지만 게임 회사에 재직하면서 neural rendering 관련 연구를 진행하면서 느낀 점인데, 단순히 빠른 속도와 좋은 real world reconstruction 만을 보여주는 3D GS 자체는 사용처가 극히 떨어진다. </p>
                            <p>따라서 neural rendering 기술을 game/graphics 엔진에서 활용하기에는 확장성이 높은 ray tracing 기반 접근법이 더 효용가치가 높을 것 같다.</p>
                        </div>
                        
                        <hr/>
                        <p>
                            You may also like, 
                        </p>
                        <ul>
                            <li>
                                <a href="../240805_gs/post.html">
                                    <span style="text-decoration: underline;">A Comprehensive Analysis of Gaussian Splatting Rasterization</span>
                                </a>
                            </li>
                        </ul>
                        <br/>
                        <div class="d-flex justify-content-start mb-4"><a class="btn btn-primary text-uppercase" href="../240721_sfm/post.html">← Older Post</a></div>
                    </div>
                </div>
            </div>
        </article>
        <!-- Footer-->
        <footer class="border-top">
            <div class="container px-4 px-lg-5">
                <div class="row gx-4 gx-lg-5 justify-content-center">
                    <div class="col-md-10 col-lg-8 col-xl-7">
                        <ul class="list-inline text-center">
                            <li class="list-inline-item">
                                <a href="https://www.linkedin.com/in/hwan-heo-0905korea/">
                                    <span class="fa-stack fa-lg">
                                        <i class="fas fa-circle fa-stack-2x"></i>
                                        <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                            <li class="list-inline-item">
                                <a href="https://github.com/hwanhuh">
                                    <span class="fa-stack fa-lg">
                                        <i class="fas fa-circle fa-stack-2x"></i>
                                        <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                        </ul>
                        <div class="small text-center text-muted fst-italic">Copyright &copy; Hwan Heo</div>
                    </div>
                </div>
            </div>
        </footer>
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="../../../js/scripts.js"></script>
        <script src="https://unpkg.com/prismjs@1.28.0/components/prism-core.min.js"></script>
        <script src="https://unpkg.com/prismjs@1.28.0/plugins/autoloader/prism-autoloader.min.js"></script>
        <script>
            Prism.plugins.autoloader.languages_path = 'https://unpkg.com/prismjs@1.28.0/components/'
        </script>
    </body>
</html>
